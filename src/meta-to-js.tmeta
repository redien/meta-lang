
number-single n
    <% n %>

number-multiple a b
    <% a %><% b %>

identifier-single n
    <% n %>

identifier-multiple a b
    <% a %><% b %>

identifierRest-single n
    <% n %>

identifierRest-multiple a b
    <% a %><% b %>

part-number number
        continuation = numberParser(<% number %>, continuation, returnFromRule, input);
    

part-identifier identifier
        continuation = identifierParser("<% identifier %>", continuation, returnFromRule, input, transform);
    

part-eof
        continuation = eofParser(continuation, returnFromRule, input);
    

parts-single n
    <% n %>

parts-multiple part _ rest
    <% rest %><% part %>

parts-none

rule-withoutSuffix name _ parts _ _
    
    addRule("<% name %>", function (input, offset, transform, continuation) {
        var returnFromRule = continuation;
        continuation = initialContinuation(returnFromRule, offset);
    <% parts %>    return cont(continuation, [], offset);
    });
    

rule-withSuffix name _ parts _ suffix _
    
    addRule("<% name %>", function (input, offset, transform, continuation) {
        var returnFromRule = continuation;
        continuation = initialSuffixContinuation("<% name %>_<% suffix %>", returnFromRule, offset, transform);
    <% parts %>    return cont(continuation, [], offset);
    });
    

suffix-suffix _ suffix
    <% suffix %>

grammar-single _ rule _
    <% rule %>

grammar-multiple _ rule _ rest
    <% rule %><% rest %>

start-start grammar _
    <% grammar %>

result
    var slice = Array.prototype.slice;
    function cont (f) {
        var args = arguments;
        var thunk = function () { return f.apply(null, slice.call(args, 1)); }
        thunk.isThunk = true;
        return thunk;
    }
    function identity (x) { return x; }
    function trampoline (thunk) {
        while (thunk && thunk.isThunk) {
            thunk = thunk();
        }
        return thunk;
    }
    var rules = {};
    function addRule (name, parseFunction) {
        let rule = rules[name];
        if (rule === undefined) {
            rule = []; 
            rules[name] = rule;
        }
        rule.push(parseFunction);
    };
    function match (alternatives, input, offset, transform, continuation) {
        if (alternatives.length === 0) {
            return cont(continuation, null);
        } else {
            return cont(alternatives[0], input, offset, transform, function (result) {
                if (result !== null) { return cont(continuation, result); }
                return cont(match, alternatives.slice(1), input, offset, transform, continuation);
            });
        }
    }
    function numberParser (number, continuation, returnFromRule, input) {
        return function (items, offset) {
            if (input.charCodeAt(offset) === number) {
                var result = {result: input[offset], start: offset, end: offset + 1};
                return cont(continuation, items.concat([result]), offset + 1);
            } else {
                return cont(returnFromRule, null);
            }
        };
    }
    function identifierParser (identifier, continuation, returnFromRule, input, transform) {
        return function (items, offset) {
            return cont(parse, identifier, input, offset, transform, function (result) {
                if (result === null) { return cont(returnFromRule, null); }
                return cont(continuation, items.concat([result]), result.end);
            });
        };
    }
    function eofParser (continuation, returnFromRule, input) {
        return function (items, offset) {
            if (offset === input.length) {
                return cont(continuation, items.concat([{result: null, start: offset, end: offset}]), offset);
            } else {
                return cont(returnFromRule, null);
            }
        };
    }
    
    function initialContinuation (returnFromRule, startOffset) {
        return function (items, offset) {
            var results = items.map(function (i) { return i.result; });
            return cont(returnFromRule, {result: results, start: startOffset, end: offset});
        };
    }
    
    function initialSuffixContinuation (transformer, returnFromRule, startOffset, transform) {
        return function (items, offset) {
            var results = items.map(function (i) { return i.result; });
            var transformedResults = transform[transformer].apply(null, results);
            return cont(returnFromRule, {result: transformedResults, start: startOffset, end: offset});
        };
    }
    function parse (name, input, offset, transform, continuation) {
        var alternatives = rules[name];
        if (alternatives === undefined) {
            throw new Error('Unknown rule ' + name);
        }
        return cont(match, alternatives, input, offset, transform, continuation);
    }
    <% result %>
    module.exports.parse = function (input, transform) {
        return trampoline(cont(parse, 'start', input, 0, transform, identity));
    };

