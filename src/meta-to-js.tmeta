
number-single n
    <% n %>

number-multiple a b
    <% a %><% b %>

identifier-single n
    <% n %>

identifier-multiple a b
    <% a %><% b %>

identifierRest-single n
    <% n %>

identifierRest-multiple a b
    <% a %><% b %>

part-number number
        
        if (input.charCodeAt(offset) === <% number %>) {
            parsed.push({result: input[offset], start: offset, end: offset + 1});
            offset += 1;
        } else {
            return null;
        }
        

part-identifier identifier
        
        parsed.push(parser.parse("<% identifier %>", input, offset, transform));
        if (parsed[parsed.length - 1] === null) { return null; }
        offset = parsed[parsed.length - 1].end;
        

part-eof
        
        if (offset === input.length) {
            parsed.push({result: null, start: offset, end: offset});
        } else {
            return null;
        }
        

parts-single n
    <% n %>

parts-multiple part _ rest
    <% part %><% rest %>

parts-none

rule-withoutSuffix name _ parts _ _
    
    parser.add("<% name %>", function (input, offset, transform) {
        var parsed = [];
        var startOffset = offset;
    <% parts %>
        var parsedResults = parsed.map(function (p) { return p.result; });
        return {result: parsedResults, start: startOffset, end: offset};
    });
    

rule-withSuffix name _ parts _ suffix _
    
    parser.add("<% name %>", function (input, offset, transform) {
        var parsed = [];
        var startOffset = offset;
    <% parts %>
        var parsedResults = parsed.map(function (p) { return p.result; });
        return {result: transform.<% name %>_<% suffix %>.apply(null, parsedResults), start: startOffset, end: offset};
    });
    

suffix-suffix _ suffix
    <% suffix %>

grammar-single _ rule _
    <% rule %>

grammar-multiple _ rule _ rest
    <% rule %><% rest %>

start-start grammar _
    <% grammar %>

result
    var parser = {rule: {}};
    parser.add = function (name, parseFunction) {
        let rule = parser.rule[name];
        if (rule === undefined) {
            rule = []; 
            parser.rule[name] = rule;
        }   
        
        rule.push(parseFunction);
    };
    
    parser.parse = function (name, input, offset, transform) {
        var alternatives = parser.rule[name];
        if (alternatives === undefined) {
            throw new Error('Unknown rule ' + name);
        }   
        
        for (var i = 0; i < alternatives.length; ++i) {
            var alternative = alternatives[i];
            var result = alternative(input, offset, transform);
            if (result !== null) { return result; }
        }   
        
        return null;
    };
    <% result %>
    module.exports.parse = function (input, transform) {
        return parser.parse('start', input, 0, transform);
    };

