
number-single n
    <% n %>

number-multiple a b
    <% a %><% b %>

identifier-single n
    <% n %>

identifier-multiple a b
    <% a %><% b %>

identifierRest-single n
    <% n %>

identifierRest-multiple a b
    <% a %><% b %>

part-number number
        continuation = numberParser(<% number %>, continuation, returnFromRule);
    

part-range from _ to
        continuation = rangeParser(<% from %>, <% to %>, continuation, returnFromRule);
    

part-identifier identifier
        continuation = identifierParser("<% identifier %>", continuation, returnFromRule, transform);
    

part-eof
        continuation = eofParser(continuation, returnFromRule);
    

parts-single n
    <% n %>

parts-multiple part _ rest
    <% rest %><% part %>

parts-none

rule-withoutSuffix name _ parts _ _
    
    addRule("<% name %>", function (iterator, transform, continuation) {
        var returnFromRule = continuation;
        continuation = initialContinuation(returnFromRule, iterator);
    <% parts %>    return cont(continuation, [], iterator);
    });
    

rule-withSuffix name _ parts _ suffix _
    
    addRule("<% name %>", function (iterator, transform, continuation) {
        var returnFromRule = continuation;
        continuation = initialSuffixContinuation("<% name %>_<% suffix %>", returnFromRule, iterator, transform);
    <% parts %>    return cont(continuation, [], iterator);
    });
    

suffix-suffix _ suffix
    <% suffix %>

grammar-single _ rule _
    <% rule %>

grammar-multiple _ rule _ rest
    <% rule %><% rest %>

start-start grammar _
    var slice = Array.prototype.slice;
    function cont (f) {
        var args = arguments;
        var thunk = function () { return f.apply(null, slice.call(args, 1)); }
        thunk.isThunk = true;
        return thunk;
    }
    function identity (x) { return x; }
    function trampoline (thunk) {
        while (thunk && thunk.isThunk) {
            thunk = thunk();
        }
        return thunk;
    }
    var rules = {};
    function addRule (name, parseFunction) {
        let rule = rules[name];
        if (rule === undefined) {
            rule = []; 
            rules[name] = rule;
        }
        rule.push(parseFunction);
    };
    function indexedIterator(input) {
        return {input: input, offset: 0};
    }
    function next(iterator) {
        return {input: iterator.input, offset: iterator.offset + 1};
    }
    function value(iterator) {
        return iterator.input.charCodeAt(iterator.offset);
    }
    function isEnd(iterator) {
        return iterator.offset === iterator.input.length;
    }
    function match (alternatives, iterator, transform, continuation) {
        if (alternatives.length === 0) {
            return cont(continuation, null);
        } else {
            return cont(alternatives[0], iterator, transform, function (result) {
                if (result !== null) { return cont(continuation, result); }
                return cont(match, alternatives.slice(1), iterator, transform, continuation);
            });
        }
    }
    function numberParser (number, continuation, returnFromRule) {
        return function (items, iterator) {
            if (value(iterator) === number) {
                var result = {result: String.fromCharCode(value(iterator)), start: iterator, end: next(iterator)};
                return cont(continuation, items.concat([result]), next(iterator));
            } else {
                return cont(returnFromRule, null);
            }
        };
    }
    function rangeParser (from, to, continuation, returnFromRule) {
        return function (items, iterator) {
            var code = value(iterator);
            if (code >= from && code <= to) {
                var result = {result: String.fromCharCode(code), start: iterator, end: next(iterator)};
                return cont(continuation, items.concat([result]), next(iterator));
            } else {
                return cont(returnFromRule, null);
            }
        };
    }
    function identifierParser (identifier, continuation, returnFromRule, transform) {
        return function (items, iterator) {
            return cont(parse, identifier, iterator, transform, function (result) {
                if (result === null) { return cont(returnFromRule, null); }
                return cont(continuation, items.concat([result]), result.end);
            });
        };
    }
    function eofParser (continuation, returnFromRule) {
        return function (items, iterator) {
            if (isEnd(iterator)) {
                return cont(continuation, items.concat([{result: null, start: iterator, end: iterator}]), iterator);
            } else {
                return cont(returnFromRule, null);
            }
        };
    }
    
    function initialContinuation (returnFromRule, startIterator) {
        return function (items, iterator) {
            var results = items.map(function (i) { return i.result; });
            return cont(returnFromRule, {result: results, start: startIterator, end: iterator});
        };
    }
    
    function initialSuffixContinuation (transformer, returnFromRule, startIterator, transform) {
        return function (items, iterator) {
            var results = items.map(function (i) { return i.result; });
            var transformedResults = transform[transformer].apply(null, results);
            return cont(returnFromRule, {result: transformedResults, start: startIterator, end: iterator});
        };
    }
    function parse (name, iterator, transform, continuation) {
        var alternatives = rules[name];
        if (alternatives === undefined) {
            throw new Error('Unknown rule ' + name);
        }
        return cont(match, alternatives, iterator, transform, continuation);
    }
    <% grammar %>
    module.exports.parse = function (input, transform) {
        return trampoline(cont(parse, 'start', indexedIterator(input), transform, identity));
    };

